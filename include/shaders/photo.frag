#version 330 core
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D uTexture;

uniform float uHighlightFactor; // 0.0 = no change, >1.0 = brighten, <1.0 = recover
uniform float uShadowsFactor; // 
uniform float uExposure; // 
uniform float uSaturation; // 
uniform float uContrast; // 


uniform float shadowLowThreshold;
uniform float shadowHighThreshold;

uniform float highlightsLowThreshold;
uniform float highlightsHighThreshold;

float srgbToLin(float channel){
    // Send this function a decimal sRGB gamma encoded color value
    // between 0.0 and 1.0, and it returns a linearized value.
    if (channel <= 0.04045)
    {
        return channel / 12.92;
    }

    return pow((( channel + 0.055)/1.055),2.4);
}

float ytoL(float y){
    // Send this function a luminance value between 0.0 and 1.0,
    // and it returns L* which is "perceptual lightness"
    if(y <= (216.0/24389.0)){  // The CIE standard states 0.008856 but 216/24389 is the intent for 0.008856451679036
        return y * (24389.0 / 27.0);  // The CIE standard states 903.3, but 24389/27 is the intent, making 903.296296296296296
    }else{
        return pow(y,(1.0/3.0))*116.0-16.0;
    }    
}

// Shadows low - high threshold. 0.5 - 0.2 // default
vec3 adjustShadows(vec3 color, float shadowsFactor, float shadowLowThres, float shadowHighThres)
{
    float r1 = srgbToLin(color.r/255.0);
    float g1 = srgbToLin(color.g/255.0);
    float b1 = srgbToLin(color.b/255.0);

    float luminance = (0.2126 * ytoL(r1) + 0.71529 * ytoL(g1) + 0.0722 * ytoL(b1));   
    //float luminance = dot(color.rgb, vec3(0.2126, 0.71529, 0.0722));
    // Shadows mask: 1.0 for shadows, fades to 0 for midtones/highlights
    // low - high / threshold
    float shadowMask = smoothstep(shadowLowThres, shadowHighThres, luminance);
    // Note: the order is reversed! (larger value first, smaller second)
    vec3 shadowAdjusted = mix(color.rgb, color.rgb * shadowsFactor, shadowMask);
    
    return shadowAdjusted;
    
}
// highlights low  - high threshold 0.2 - 0.8 // default
vec3 adjustHighlights(vec3 color, float highFactor, float highLowThres, float highHighThres){

    float r1 = srgbToLin(color.r/255.0);
    float g1 = srgbToLin(color.g/255.0);
    float b1 = srgbToLin(color.b/255.0);

    // 2.2 gamma 
    float luminance = (0.2126 * ytoL(r1) + 0.71529 * ytoL(g1) + 0.0722 * ytoL(b1));
    //float luminance = dot(color.rgb, vec3(0.2126, 0.71529, 0.0722));
    // low - high / threshold
    float highlightMask = smoothstep(highLowThres, highHighThres, luminance);      
    vec3 highlightAdjusted = mix(color.rgb, color.rgb * highFactor, highlightMask);
    
    return highlightAdjusted;

}

vec3 adjustExposure(vec3 color, float exposure) {
    return color * pow(2.0, exposure);
}

vec3 adjustSaturation(vec3 color, float saturation) {
    // relative luminance base
    // 2.2 gamma  
    const vec3 luminanceWeighting = vec3(0.2126, 0.71529, 0.0722);
    vec3 grayscaleColor = vec3(dot(color, luminanceWeighting));
    return mix(grayscaleColor, color, 1.0 + saturation);
}

vec3 adjustContrast(vec3 color, float contrast) {
    return 0.5 + (contrast + 1.0) * (color.rgb - 0.5);
}
void main() {

    vec4 color = texture(uTexture, TexCoords);

    // Compute simple luminance
    //float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
    color.rgb = adjustContrast(color.rgb, uContrast);
    color.rgb = adjustSaturation(color.rgb, uSaturation);
    color.rgb = adjustExposure(color.rgb, uExposure);
    color.rgb = adjustHighlights(color.rgb, uHighlightFactor, highlightsLowThreshold, highlightsHighThreshold);
    color.rgb = adjustShadows(color.rgb, uShadowsFactor, shadowLowThreshold, shadowHighThreshold);
    
    FragColor = color;
}


// A Fragment Shader is the Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value.
// The fragment shader is the OpenGL pipeline stage after a primitive is rasterized. For each sample of the pixels covered by a primitive, 
// a "fragment" is generated. Each fragment has a Window Space position, a few other values, and it contains all of the interpolated per-vertex output values from the last Vertex Processing stage.
// The output of a fragment shader is a depth value, a possible stencil value (unmodified by the fragment shader), 
// and zero or more color values to be potentially written to the buffers in the current framebuffers.
// Fragment shaders take a single fragment as input and produce a single fragment as output. 
// https://www.khronos.org/opengl/wiki/Fragment_Shader